{"backend_state":"running","connection_file":"/projects/616bebf1-83bb-4da8-a0be-bad824c72dfe/.local/share/jupyter/runtime/kernel-7b085e06-734a-4c9e-b091-bc1537c06fd1.json","kernel":"python3-ubuntu","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1685100845225,"exec_count":2,"id":"e16afd","input":"from glob import glob\n\nfilepaths = glob('./data/*.tif')\n\nfilepaths","kernel":"python3-ubuntu","output":{"0":{"data":{"text/plain":"['./data/IXMtest_A18_s6_w17AEEB754-2604-4D00-9879-76EF073B7202.tif',\n './data/segmentation_nuclei.tif',\n './data/Hoechst_C21_08.tif',\n './data/Hoechst_C21_06.tif',\n './data/nuclei_lamin_002.tif',\n './data/Hoechst_D21_01.tif',\n './data/IXMtest_A18_s2_w1BB7E78F9-CC00-4654-9AF4-F24FBA20E630.tif',\n './data/IXMtest_A18_s1_w1BFDF1C94-9C1F-4F5F-BBC1-05196333B1BF.tif',\n './data/Hoechst_D21_00.tif',\n './data/Hoechst_C21_01.tif',\n './data/Hoechst_C21_07.tif',\n './data/segmentation_mask_gt.tif',\n './data/IXMtest_A18_s5_w18504E02A-DE75-460B-BD1A-3001AC0DD626.tif',\n './data/Hoechst_C21_00.tif',\n './data/Hoechst_D21_06.tif',\n './data/Hoechst_D21_08.tif',\n './data/nuclei_crop.tif',\n './data/IXMtest_A17_s9_w11BD1E0C1-B400-44F3-B4B8-9335F645310E.tif',\n './data/nuclei_dapi_002.tif',\n './data/Hoechst_D21_03.tif',\n './data/Hoechst_C21_02.tif',\n './data/IXMtest_A18_s3_w1737EE06A-26D0-413B-9C92-C24152DD4750.tif',\n './data/Hoechst_D21_04.tif',\n './data/Hoechst_C21_05.tif',\n './data/IXMtest_A18_s4_w1830F3981-DCE2-40FC-B053-FE6B5DE54499.tif',\n './data/Hoechst_C21_04.tif',\n './data/Hoechst_D21_05.tif',\n './data/Hoechst_D21_07.tif',\n './data/Hoechst_D21_02.tif',\n './data/IXMtest_K12_s1_w193D6C057-1AA9-4E2F-86EA-2E71961BE68B.tif',\n './data/Hoechst_C21_03.tif']"},"exec_count":2}},"pos":1,"start":1685100845202,"state":"done","type":"cell"}
{"cell_type":"code","end":1685100845543,"exec_count":3,"id":"86d335","input":"from skimage.io import imread\n\n\nimages_path = [s for s in filepaths if \"Hoechst_\" in s]\nimages = [imread(image) for image in images_path]","kernel":"python3-ubuntu","pos":3,"start":1685100845236,"state":"done","type":"cell"}
{"cell_type":"code","end":1685100846250,"exec_count":4,"id":"cc8193","input":"from skimage.filters import threshold_otsu\nfrom matplotlib import pyplot as plt\n\n\nthreshold = threshold_otsu(images[1])\n\nprint(threshold)\notsu_thresholded_image = images[1] > threshold\n\n# Maybe side by side comparison here\nplt.imshow(otsu_thresholded_image)","kernel":"python3-ubuntu","output":{"0":{"name":"stdout","text":"4095\n"},"1":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f6ac4a23fd0>"},"exec_count":4},"2":{"data":{"image/png":"8228cb9ea66cc8898c1977065307dbbca3392e81","text/plain":"<Figure size 864x504 with 1 Axes>"},"metadata":{"image/png":{"height":414,"width":549},"needs_background":"light"}}},"pos":5,"start":1685100845551,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101002576,"exec_count":5,"id":"315c2c","input":"from skimage.filters import try_all_threshold\n\nfig, ax = try_all_threshold(images[1], figsize=(6, 12), verbose=False)\nplt.show()\n#Isodata, Li, Mean, triangle, Yen have good performance for the images[1]","kernel":"python3-ubuntu","output":{"0":{"data":{"image/png":"57cfb094e0bf34d2378325cbaceeb00278550f25","text/plain":"<Figure size 432x864 with 8 Axes>"},"metadata":{"image/png":{"height":819,"width":424},"needs_background":"light"}}},"pos":7,"start":1685100846259,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101002604,"exec_count":6,"id":"527b1f","input":"from skimage.filters import threshold_mean\n\nmean_thresholded_images = []\nfor image in images:\n    threshold = threshold_mean(image)\n    mean_thresholded_image = image > threshold\n    mean_thresholded_images.append(mean_thresholded_image)","kernel":"python3-ubuntu","pos":10,"start":1685101002584,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101002623,"exec_count":7,"id":"0e156a","input":"mean_intensity = []\nfor num in range(0,len(images)):\n    mean_intensity.append(images[num][mean_thresholded_images[num]].mean())\nprint(mean_intensity)","kernel":"python3-ubuntu","output":{"0":{"name":"stdout","text":"[780.2341986096052, 809.3222942164626, 776.7730218281037, 790.9806025588114, 833.1525976872643, 817.6958537702646, 895.3445201289748, 818.3901839629266, 749.7687913512038, 797.399798257361, 792.6142940341426, 785.3364741943266, 923.2394268929384, 817.0000104007405, 770.9746046256513, 819.4152769482856, 782.9578548315462, 796.3104900920222]\n"}},"pos":12,"start":1685101002609,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101002669,"exec_count":8,"id":"7a4b34","input":"new_mean_intensity = []\nfor num in range(0,len(images)):\n    new_mean_intensity.append(images[num][mean_thresholded_images[num]].mean()-images[num][mean_thresholded_images[num]!=True].mean())\nprint(new_mean_intensity)","kernel":"python3-ubuntu","output":{"0":{"name":"stdout","text":"[597.4418029792803, 641.0086919607295, 472.3345400849678, 481.99432267253854, 644.2868086094269, 640.2854755633246, 706.2049924287332, 516.6038126652204, 443.5483584781773, 493.58665461746756, 597.961906204219, 484.5360343262184, 729.2051578487687, 640.1747271703146, 467.0297043082943, 514.8381696153097, 474.9127826276891, 616.4461243493477]\n"}},"pos":14,"start":1685101002630,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101002765,"exec_count":9,"id":"003342","input":"C21_images_path = [s for s in filepaths if \"Hoechst_C21\" in s]\nC21_images = [imread(image) for image in C21_images_path]\nD21_images_path = [s for s in filepaths if \"Hoechst_D21\" in s]\nD21_images = [imread(image) for image in D21_images_path]\n\nC21_mean_thresholded_images = []\nfor image in C21_images:\n    threshold = threshold_mean(image)\n    mean_thresholded_image = image > threshold\n    C21_mean_thresholded_images.append(mean_thresholded_image)\n\nD21_mean_thresholded_images = []\nfor image in D21_images:\n    threshold = threshold_mean(image)\n    mean_thresholded_image = image > threshold\n    D21_mean_thresholded_images.append(mean_thresholded_image)\n\nC21_mean_intensity = []\nfor num in range(0,len(C21_images)):\n    C21_mean_intensity.append(C21_images[num][C21_mean_thresholded_images[num]].mean()-C21_images[num][C21_mean_thresholded_images[num]!=True].mean())\nprint(C21_mean_intensity)\n\nD21_mean_intensity = []\nfor num in range(0,len(D21_images)):\n    D21_mean_intensity.append(D21_images[num][D21_mean_thresholded_images[num]].mean()-D21_images[num][D21_mean_thresholded_images[num]!=True].mean())\nprint(D21_mean_intensity)\n\nfrom scipy.stats import ttest_ind\n\nttest_ind(D21_mean_intensity, C21_mean_intensity)\n#Seems the p-value is lower than 0.05, it is significantly different","kernel":"python3-ubuntu","output":{"0":{"name":"stdout","text":"[597.4418029792803, 641.0086919607295, 644.2868086094269, 640.2854755633246, 706.2049924287332, 597.961906204219, 729.2051578487687, 640.1747271703146, 616.4461243493477]\n[472.3345400849678, 481.99432267253854, 516.6038126652204, 443.5483584781773, 493.58665461746756, 484.5360343262184, 467.0297043082943, 514.8381696153097, 474.9127826276891]\n"},"1":{"data":{"text/plain":"Ttest_indResult(statistic=-9.654452581820923, pvalue=4.470447117688589e-08)"},"exec_count":9}},"pos":16,"start":1685101002681,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101002781,"exec_count":10,"id":"f0d6c6","input":"from skimage.io import imread\n\nstack = imread('/projects/616bebf1-83bb-4da8-a0be-bad824c72dfe/handouts/day3/data/dapi_stack.tif')","kernel":"python3-ubuntu","pos":18,"start":1685101002772,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101002865,"exec_count":11,"id":"28d542","input":"from skimage.io import imsave\n\nlen(stack)\nfor num in range(0, len(stack)):\n    imsave(str(num) + \"_dapi.tif\", stack[num])","kernel":"python3-ubuntu","pos":20,"start":1685101002788,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101003238,"exec_count":12,"id":"0469ea","input":"crop_image = imread('data/nuclei_crop.tif')\nplt.figure()\nplt.imshow(crop_image)","kernel":"python3-ubuntu","output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f6ac478d910>"},"exec_count":12},"1":{"data":{"image/png":"50b72a845fa66e36c670efbca0dd280b083055c1","text/plain":"<Figure size 864x504 with 1 Axes>"},"metadata":{"image/png":{"height":413,"width":509},"needs_background":"light"}}},"pos":23,"start":1685101002873,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101003591,"exec_count":13,"id":"cf9108","input":"thresholded_image = crop_image > 300\nplt.imshow(thresholded_image)","kernel":"python3-ubuntu","output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f6ac4776e80>"},"exec_count":13},"1":{"data":{"image/png":"671bc550b1f5cb5658d661b9edc202ad749cf16f","text/plain":"<Figure size 864x504 with 1 Axes>"},"metadata":{"image/png":{"height":413,"width":509},"needs_background":"light"}}},"pos":25,"start":1685101003254,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101003940,"exec_count":14,"id":"4f6d78","input":"from skimage.morphology import binary_erosion\n\neroded_mask = binary_erosion(thresholded_image)\n\nplt.imshow(eroded_mask)","kernel":"python3-ubuntu","output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f6ac448f9d0>"},"exec_count":14},"1":{"data":{"image/png":"bc83920e8c17477ed64d20c25413bce296d4318e","text/plain":"<Figure size 864x504 with 1 Axes>"},"metadata":{"image/png":{"height":413,"width":509},"needs_background":"light"}}},"pos":27,"start":1685101003599,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101004298,"exec_count":15,"id":"c231e5","input":"plt.imshow(thresholded_image ^ eroded_mask)","kernel":"python3-ubuntu","output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f6ac4465be0>"},"exec_count":15},"1":{"data":{"image/png":"4f3c25421c552b3811631bc5d164e775bc340563","text/plain":"<Figure size 864x504 with 1 Axes>"},"metadata":{"image/png":{"height":413,"width":509},"needs_background":"light"}}},"pos":29,"start":1685101003959,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101004314,"exec_count":16,"id":"44f37b","input":"exclusive_or = thresholded_image ^ eroded_mask\nexclusive_or.sum()","kernel":"python3-ubuntu","output":{"0":{"data":{"text/plain":"156"},"exec_count":16}},"pos":31,"start":1685101004307,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101004936,"exec_count":17,"id":"20d334","input":"from skimage.io import imread\nfrom matplotlib import pyplot as plt\n\nimg_dapi = imread('data/nuclei_dapi_002.tif')\nimg_fluo = imread('data/nuclei_lamin_002.tif')\n\nfig, axs = plt.subplots(ncols=2)\naxs[0].imshow(img_dapi)\naxs[1].imshow(img_fluo)","kernel":"python3-ubuntu","output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f6ac43ff100>"},"exec_count":17},"1":{"data":{"image/png":"2927003cb5a873f498fa521cff81bc67f951f8ab","text/plain":"<Figure size 864x504 with 2 Axes>"},"metadata":{"image/png":{"height":338,"width":711},"needs_background":"light"}}},"pos":33,"start":1685101004324,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101005300,"exec_count":18,"id":"704cce","input":"threshold_img_dapi = img_dapi > img_dapi.mean()\nplt.imshow(threshold_img_dapi)","kernel":"python3-ubuntu","output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f6ac436f730>"},"exec_count":18},"1":{"data":{"image/png":"2904e123426f63b1687b674d3ab38fd4f57159c9","text/plain":"<Figure size 864x504 with 1 Axes>"},"metadata":{"image/png":{"height":414,"width":421},"needs_background":"light"}}},"pos":35,"start":1685101004956,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101005645,"exec_count":19,"id":"0a655c","input":"from skimage.morphology import disk\n\ndisk(5)\neroded_mask = binary_erosion(threshold_img_dapi, disk(5))\n\nplt.imshow(threshold_img_dapi ^ eroded_mask)","kernel":"python3-ubuntu","output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f6ac03a77f0>"},"exec_count":19},"1":{"data":{"image/png":"a5a5bfbca6cce12c3a491d56b2fbe303864c3552","text/plain":"<Figure size 864x504 with 1 Axes>"},"metadata":{"image/png":{"height":414,"width":421},"needs_background":"light"}}},"pos":37,"start":1685101005308,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101005664,"exec_count":20,"id":"8737da","input":"border = threshold_img_dapi ^ eroded_mask\nborder_mean_intensity = img_fluo[border].mean()\nprint(\"The mean intensity on the nuclear border: \"+ str(border_mean_intensity))\n\neroded_mask = binary_erosion(img_fluo)\nmean_intensity = (img_fluo[eroded_mask]).mean()\nprint(\"The mean intensity in the interior of nuclei: \"+ str(mean_intensity))","kernel":"python3-ubuntu","output":{"0":{"name":"stdout","text":"The mean intensity on the nuclear border: 44.34839160839161\nThe mean intensity in the interior of nuclei: 24.522833678716708\n"}},"pos":39,"start":1685101005653,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101005677,"exec_count":21,"id":"74c010","input":"ratio = border_mean_intensity/mean_intensity\nprint(ratio)","kernel":"python3-ubuntu","output":{"0":{"name":"stdout","text":"1.808452978534917\n"}},"pos":41,"start":1685101005670,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101645267,"exec_count":23,"id":"da106a","input":"img = imread('data/segmentation_nuclei.tif')\ngt_mask = imread('data/segmentation_mask_gt.tif')\n\n# NOTE: in the file, foreground has value 255, bg 0 -> convert to boolean array\ngt_mask = gt_mask > 0\n\nfig, axs = plt.subplots(ncols=2)\naxs[0].imshow(img)\naxs[1].imshow(gt_mask)","kernel":"python3-ubuntu","output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f6abb5c1f40>"},"exec_count":23},"1":{"data":{"image/png":"b6720a8d93711731c771ce7e51b7289698a112ef","text/plain":"<Figure size 864x504 with 2 Axes>"},"metadata":{"image/png":{"height":261,"width":710},"needs_background":"light"}}},"pos":43,"start":1685101644350,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101681638,"exec_count":25,"id":"95c966","input":"from skimage.filters import threshold_li\n\n\nthresholded_img = img > threshold_li(img)\nplt.imshow(thresholded_img)","kernel":"python3-ubuntu","output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f6abadc18b0>"},"exec_count":25},"1":{"data":{"image/png":"31ecf0a8669938e3631c6e7d025f626706e09906","text/plain":"<Figure size 864x504 with 1 Axes>"},"metadata":{"image/png":{"height":414,"width":549},"needs_background":"light"}}},"pos":45,"start":1685101681124,"state":"done","type":"cell"}
{"cell_type":"code","end":1685101784926,"exec_count":29,"id":"8b2c49","input":"inter.sum()/union.sum()","kernel":"python3-ubuntu","output":{"0":{"data":{"text/plain":"0.7353153731882603"},"exec_count":29}},"pos":49,"start":1685101784899,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":28,"id":"78fece","input":"fig, axs = plt.subplots(ncols=2)\n\ninter = thresholded_img & gt_mask\nprint(inter.sum())\naxs[0].imshow(inter)\n\nunion = thresholded_img | gt_mask\nprint(union.sum())\naxs[1].imshow(union)","kernel":"python3-ubuntu","output":{"0":{"name":"stdout","text":"73258\n"},"1":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f6ab9a01df0>"},"exec_count":28},"2":{"data":{"image/png":"ec35c52009a4edfd576812d3fef159f365b59eec","text/plain":"<Figure size 864x504 with 2 Axes>"},"metadata":{"image/png":{"height":261,"width":710},"needs_background":"light"}}},"pos":47,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"0a8c66","input":"* calculate the ratio of fluorecense at the border and in the center","pos":40,"type":"cell"}
{"cell_type":"markdown","id":"0b8108","input":"## Task Z Planes\n\na) Load the 3d image stack in file \"./data/dapi_stack.tif\"","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"12169b","input":"* Try Otsu Thresholding on one of the loaded images:","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"1c3706","input":"## Imageloading + Thresholding + Measurement\n\nYou can use the  ```glob``` module to get a list of all matching filepaths in a folder. The ```*``` symbol tells glob to consider all possibilities, and thus glob will find all .tif files with arbitrary filename in the given folder path.","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"213024","input":"* Choose a good Segmentation algorithm of the above and create a list of segmented masks for all *Hoechst_\\** images. \n\nYou can find the exact function names you need to import either by googling ``` skimage filters ``` (the submodule that also threshold_otsu is in) or under this link next to threshold_otsu:\n\nhttps://scikit-image.org/docs/dev/api/skimage.filters.html\n\n","pos":9,"type":"cell"}
{"cell_type":"markdown","id":"22046c","input":"- use the mask of the border to index into `img_fluo` and measure the mean intensity on the nuclear border\n- use the eroded mask to  \n   measure the mean intensity of `img_fluo` in the interior of nuclei\n\n","pos":38,"type":"cell"}
{"cell_type":"markdown","id":"262d1e","input":"* The mean intensities are pretty similar for all images, but the images all have different background intensities that we have to account for.\n\nTake the mean intensities of above and subtract each value with the mean intensity of the respective background. Then print the mean intensities again.\n\nTip: Inverting your segmentation of the nuclei yields a mask for the background.\n\n**It is almost always a good idea to subtract background intensities if you want to perform quantativie measurements in images!**\n\n","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"2f6056","input":"b) Go through all z-planes in the stack and save them as individual files (Make sure to use different filenames for each plane, e.g. you could add the z-index to the filename)","pos":19,"type":"cell"}
{"cell_type":"markdown","id":"3451ca","input":"* Sum up the pixels in your outline mask - *this corresponds to the length of the outline, i.e. the circumference of the cell*","pos":30,"type":"cell"}
{"cell_type":"markdown","id":"36a58c","input":"* create a mask of the cells from the DAPI image using thresholding","pos":34,"type":"cell"}
{"cell_type":"markdown","id":"405743","input":"- `Calculate the exclusive OR (^ operator) of the original and eroded mask and display it - it should be just a ring corresponding to the outline of the cell`\n\n","pos":28,"type":"cell"}
{"cell_type":"markdown","id":"43a368","input":"### Overlap of two masks\n\nUsing binary operations, on can quantify the similarity of two masks, e.g. to compare the performance of different segmentations algorithms with manual human annotations.\n\nIn this context, masks created by a human annotator are usually called the ground-truth (GT).\n\nHere, we are loading an image of nucl  \nei as well as manual annoatations:\n","pos":42,"type":"cell"}
{"cell_type":"markdown","id":"4b3c4f","input":"## Tasks on Morphological Operations and binary images\n\nMorphological operations provide a way of extracting a variety of measurements from your images, if you combine them in a clever way.\n\nIn the following tasks, you can try it yourself on three examples:","pos":21,"type":"cell"}
{"cell_type":"markdown","id":"4c8700","input":"* given the ground truth and segmentation mask, calculate the intersection of both (using binary AND)\n* given the ground truth and segmentation mask, calculate the union of both (using binary OR)","pos":46,"type":"cell"}
{"cell_type":"markdown","id":"6dc681","input":"* calculate the intersection-over-union (**IoU** = number of pixels in intersection divided by number of pixels in union) from the number of pixels in both masks\n* **OPTIONAL:** compare different thresholding strategies\n    You could:\n    * apply a small amount of blur to the image before calculating the threshold\n    * try different automatic threshold algorithms\n    * apply some morphological operations to clean up the binary image after thresholding\n\n","pos":48,"type":"cell"}
{"cell_type":"markdown","id":"780115","input":"* segment the image using thresholding and create a segmentation mask","pos":44,"type":"cell"}
{"cell_type":"markdown","id":"797f89","input":"There are images from two different datasets mixed together in the folder. Separate them and only load the *Hoechst_\\** images.\n\n* Load all *Hoechst_\\** images in ```filepaths``` and put them into a list ```images```:","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"7dd886","input":"c) If you look at the file names of the Hoechst* images, you can see that they actually correspond to two different wells in a multiwell experiment (C21 and D21).\nSplit the mean values you just calculated according the the well of the image file and print them.\n\n**Bonus:** you could even collect the values in 2 lists and do a statistical test to see if they differ significantly. For example, you could run ```from scipy.stats import ttest_ind``` to get a function ```ttest_ind``` that performs a t-test.\n\n","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"8906a3","input":"* Segment the cell (create a binary mask) in the image using thresholding","pos":24,"type":"cell"}
{"cell_type":"markdown","id":"9054b1","input":"* Use binary erosion to create a version of the mask that is shrunk by 1 pixel","pos":26,"type":"cell"}
{"cell_type":"markdown","id":"9cc7be","input":"**The reason Otsu thresholding does not work for these images is because they have *hot pixels* (with intensity 65535) in them. *Hot pixels* are caused by broken sensor elements and can be quite common in old cameras. They might not matter much to us if we look at the images, but a simple tresholding algorithm can be thrown off by them. It is always good to look at the results of you segmentation to make sure an automated procedure actually computed something reasonable!**","pos":8,"type":"cell"}
{"cell_type":"markdown","id":"a0fd02","input":"* Try all other thresholding algorithms to see if we can find one that is better:","pos":6,"type":"cell"}
{"cell_type":"markdown","id":"a35960","input":"### Measuring signal at just the border of cells\n\nWe can use a similar strategy to measure intensity in a separate channel at just the border of cells.\n\nWe will be using DAPI stained nuclei to segment the nuclei and a *simulated* Lamin channel in which we want to do our measurements:","pos":32,"type":"cell"}
{"cell_type":"markdown","id":"c19f0e","input":"### Measuring the circumference of a cell\n\n* Load the image ```'data/nuclei_crop.tif'``` and plot it","pos":22,"type":"cell"}
{"cell_type":"markdown","id":"d033a1","input":"* use erosion to shrink the mask by 5 pixels and calculate the XOR with the original mask\n\n","pos":36,"type":"cell"}
{"cell_type":"markdown","id":"f39339","input":"* Try to get the mean intensity of the nuclei in each *Hoechst_\\** image and print them.\n\nYou have to use the segmented masks you created above and use them as binary masks","pos":11,"type":"cell"}
{"id":0,"time":1685013920626,"type":"user"}
{"last_load":1685100267860,"type":"file"}